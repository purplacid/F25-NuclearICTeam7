import osmnx as ox
import networkx as nx
import geopandas as gpd
import folium
from shapely.geometry import Point, LineString
from shapely.ops import unary_union
from math import radians, sin, cos, atan2, sqrt
import pandas as pd
import requests
import polyline
import time
start_time = time.time()
def haversine(n1, n2, G):
    """Return great-circle distance (km) between two graph nodes."""
    lon1, lat1 = G.nodes[n1]['x'], G.nodes[n1]['y']
    lon2, lat2 = G.nodes[n2]['x'], G.nodes[n2]['y']
    R = 6371.0
    dlon, dlat = radians(lon2 - lon1), radians(lat2 - lat1)
    a = sin(dlat / 2) ** 2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon / 2) ** 2
    return 2 * R * atan2(sqrt(a), sqrt(1 - a))


# --- Load data and graph -------------------------------------------------
sites = gpd.read_file("nuclear_sites.geojson").to_crs(epsg=4326)
G = ox.load_graphml("ON_MB_Road_Data.graphml")

# Named origin nodes
origins = {
    "Bruce": ox.distance.nearest_nodes(
        G, sites[sites["Name"] == "Bruce Power"].geometry.iloc[0].x,
        sites[sites["Name"] == "Bruce Power"].geometry.iloc[0].y
    ),
    "Pickering": ox.distance.nearest_nodes(
        G, sites[sites["Name"] == "Pickering"].geometry.iloc[0].x,
        sites[sites["Name"] == "Pickering"].geometry.iloc[0].y
    ),
    "Darlington": ox.distance.nearest_nodes(
        G, sites[sites["Name"] == "Darlington"].geometry.iloc[0].x,
        sites[sites["Name"] == "Darlington"].geometry.iloc[0].y
    ),
    "Chalk River": ox.distance.nearest_nodes(
        G, sites[sites["Name"] == "Chalk River"].geometry.iloc[0].x,
        sites[sites["Name"] == "Chalk River"].geometry.iloc[0].y
    ),
}

# Destination
ignace = ox.distance.nearest_nodes(
    G, sites[sites["Name"] == "Ignace"].geometry.iloc[0].x,
    sites[sites["Name"] == "Ignace"].geometry.iloc[0].y,
)



# --- Hazards: load, buffer and enforce avoidant pathing ---------------
# Load hazards and build buffers; these buffers are used to inflate edge lengths
# so routing avoids them. Radii (in degrees) are heuristics and can be tuned.
hazards_df = pd.read_csv("Hazards.csv")
traffic_df = pd.read_csv("TrafficToAvoid.csv")

# --- Fetch API data for road conditions and rest areas ---
import concurrent.futures
import functools

def fetch_api_data(url, timeout=10):
    try:
        resp = requests.get(url, timeout=timeout)
        return resp.json()
    except Exception:
        return None

def fetch_road_condition_segments():
    url = "https://511on.ca/api/v2/get/roadconditions"
    # Fetching road conditions (silent)
    data = fetch_api_data(url)
    if not data:
        return {"drifting": [], "visibility": []}
    
    drifting_hazards = []
    visibility_hazards = []
    
    for seg in data:
        drifting = seg.get("Drifting", "No")
        visibility = seg.get("Visibility", "Good")
        poly = seg.get("EncodedPolyline")
        
        if poly:
            coords = polyline.decode(poly)
            if drifting == "Yes":
                drifting_hazards.append({
                    "geometry": LineString(coords),
                    "type": "Drifting Snow",
                    "description": "Road affected by drifting snow"
                })
            if visibility in ["Poor", "Very Poor"]:
                visibility_hazards.append({
                    "geometry": LineString(coords),
                    "type": "Poor Visibility",
                    "description": f"Road affected by {visibility.lower()} visibility conditions"
                })
    
    return {
        "drifting": drifting_hazards,
        "visibility": visibility_hazards
    }

# Example road conditions and construction delays to demonstrate impact
def get_example_road_conditions():
    return {
        "drifting": [
            {
                "type": "Drifting Snow",
                "location": [48.3809, -89.2477],  # Near Thunder Bay
                "description": "Moderate snow drifting on Trans-Canada"
            },
            {
                "type": "Drifting Snow",
                "location": [46.3134, -79.4608],  # Near North Bay
                "description": "Heavy snow drifting on Highway 17"
            }
        ],
        "visibility": [
            {
                "type": "Poor Visibility",
                "location": [45.0153, -74.7299],  # Near Cornwall
                "description": "Dense fog reducing visibility"
            },
            {
                "type": "Poor Visibility",
                "location": [44.2312, -76.4860],  # Near Kingston
                "description": "Heavy snowfall reducing visibility"
            },
            {
                "type": "Poor Visibility",
                "location": [47.5615, -84.3332],  # Near Wawa
                "description": "Blowing snow reducing visibility"
            }
        ]
    }

# Example construction delays to demonstrate impact
def get_example_construction_delays():
    # These are example coordinates along major highways
    return [
        {
            "type": "Construction",
            "location": [45.4215, -75.6972],  # Near Ottawa
            "description": "Major bridge repair (60min delay)",
            "delay_minutes": 60
        },
        {
            "type": "Construction",
            "location": [43.6532, -79.3832],  # Near Toronto
            "description": "Road widening (30min delay)",
            "delay_minutes": 30
        },
        {
            "type": "Construction",
            "location": [46.4917, -80.9930],  # Near Sudbury
            "description": "Emergency repairs (45min delay)",
            "delay_minutes": 45
        }
    ]

def fetch_truck_rest_areas():
    url = "https://511on.ca/api/v2/get/truckrestareas"
    # Fetching truck rest areas (silent)
    data = fetch_api_data(url)
    if not data:
        return []
    
    rest_areas = []
    for area in data:
        try:
            if "EncodedPolyline" in area:
                coords = polyline.decode(area["EncodedPolyline"])[0]
                rest_areas.append({
                    "lat": coords[0],
                    "lon": coords[1],
                    "name": area.get("LocationDescription", "Truck Rest Area")
                })
            elif "Latitude" in area and "Longitude" in area:
                rest_areas.append({
                    "lat": float(area["Latitude"]),
                    "lon": float(area["Longitude"]),
                    "name": area.get("LocationDescription", "Truck Rest Area")
                })
        except Exception as e:
            print(f"Error processing rest area: {e}")
            continue
    return rest_areas

def fetch_all_api_data():
    """Fetch all API data in parallel"""
    urls = {
        'road_conditions': "https://511on.ca/api/v2/get/roadconditions",
        'rest_areas': "https://511on.ca/api/v2/get/truckrestareas",
        'construction': "https://511on.ca/api/v2/get/constructionprojects"
    }
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
        futures = {executor.submit(fetch_api_data, url): name 
                  for name, url in urls.items()}
        results = {}
        for future in concurrent.futures.as_completed(futures):
            name = futures[future]
            try:
                results[name] = future.result()
            except Exception as e:
                pass
                results[name] = None
    return results

def hazard_radius(name: str) -> float:
    if "Fire" in name:
        return 0.18  # 20 km in degrees (halved from 40km)
    if "Flood" in name:
        return 0.05  # Halved from 0.10
    if "Construction" in name:
        return 0.047  # ~5.25km in degrees (75% of original 7km)
    if "Traffic" in name or "Poor Road" in name or "PoorRoad" in name:
        return 0.063  # ~7km in degrees for all traffic-related hazards
    return 0.05  # Halved from 0.10

# Add geometry to hazards_df efficiently using vectorized operations
hazards_df["geometry"] = gpd.points_from_xy(hazards_df["Longitude"], hazards_df["Latitude"])

# Import and integrate construction hazards
from nic_utils import fetch_construction_sites
print("Fetching construction sites from 511on.ca...")

# Create a compiled regex pattern for delay extraction
import re
delay_pattern = re.compile(r'up to (\d+) minutes')

try:
    # Get all API data in parallel
    api_data = fetch_all_api_data()
    construction_hazards = []
    
    if api_data.get('construction'):
        for site in api_data['construction']:
            desc = str(site.get('Description', '')).lower()
            
            # Extract delay using compiled regex
            delay = 0
            match = delay_pattern.search(desc)
            if match:
                try:
                    delay = int(match.group(1))
                except ValueError:
                    pass
        
        # Scale buffer radius based on delay (max 3km = 0.027 degrees)
        # 10 min = 1km, 30+ min = 3km, linear scale between
        radius = min(0.009 + (delay - 10) * (0.027 - 0.009) / 20, 0.027) if delay >= 10 else 0.009
        
        construction_hazards.append({
            "Hazards": f"Construction ({delay}min delay)",
            "Latitude": site.geometry.y,
            "Longitude": site.geometry.x,
            "geometry": site.geometry
        })
except Exception as e:
    pass
    construction_hazards = []

# Integrate traffic as hazards
traffic_hazards = []
for _, row in traffic_df.iterrows():
    try:
        lat = float(row["CORRESPONDING LAT"])
        lon = float(row["corr long"])
        if not (pd.isna(lat) or pd.isna(lon)):
            traffic_hazards.append({
                "Hazards": "Traffic",
                "Latitude": lat,
                "Longitude": lon,
                "geometry": Point(lon, lat)
            })
    except Exception:
        continue

if traffic_hazards:
    traffic_df2 = pd.DataFrame(traffic_hazards)
    hazards_df = pd.concat([hazards_df, traffic_df2], ignore_index=True)

# Add construction hazards
if construction_hazards:
    construction_df = pd.DataFrame(construction_hazards)
    hazards_df = pd.concat([hazards_df, construction_df], ignore_index=True)

# Calculate all buffer radii at once using vectorized operations
hazards_df['buffer_radius'] = hazards_df['Hazards'].apply(hazard_radius)

# Build buffers efficiently in chunks
def chunk_buffer(geometries, radii, chunk_size=100):
    buffers = []
    for i in range(0, len(geometries), chunk_size):
        chunk_geoms = geometries[i:i + chunk_size]
        chunk_radii = radii[i:i + chunk_size]
        buffers.extend([g.buffer(r) for g, r in zip(chunk_geoms, chunk_radii)])
    return buffers

hazard_buffers = chunk_buffer(hazards_df['geometry'].values, hazards_df['buffer_radius'].values)

# Add sample road condition hazards
road_conditions = get_example_road_conditions()

# Add drifting snow samples
for hazard in road_conditions["drifting"]:
    hazards_df = pd.concat([hazards_df, pd.DataFrame([{
        "Hazards": f"Drifting Snow - {hazard['description']}",
        "Latitude": hazard["location"][0],
        "Longitude": hazard["location"][1],
        "geometry": Point(hazard["location"][1], hazard["location"][0])
    }])], ignore_index=True)

# Add poor visibility samples
for hazard in road_conditions["visibility"]:
    hazards_df = pd.concat([hazards_df, pd.DataFrame([{
        "Hazards": f"Poor Visibility - {hazard['description']}",
        "Latitude": hazard["location"][0],
        "Longitude": hazard["location"][1],
        "geometry": Point(hazard["location"][1], hazard["location"][0])
    }])], ignore_index=True)

# Add example construction delays
for delay in get_example_construction_delays():
    hazards_df = pd.concat([hazards_df, pd.DataFrame([{
        "Hazards": f"Construction ({delay['delay_minutes']}min delay)",
        "Latitude": delay["location"][0],
        "Longitude": delay["location"][1],
        "geometry": Point(delay["location"][1], delay["location"][0])
    }])], ignore_index=True)

# Recalculate buffer radii for all hazards
hazards_df['buffer_radius'] = hazards_df['Hazards'].apply(hazard_radius)

# Rebuild buffers efficiently in chunks
hazard_buffers = chunk_buffer(hazards_df['geometry'].values, hazards_df['buffer_radius'].values)

# Create union of buffers in chunks to improve performance
def chunked_union(geometries, chunk_size=100):
    unions = []
    for i in range(0, len(geometries), chunk_size):
        chunk = geometries[i:i + chunk_size]
        unions.append(unary_union(chunk))
    return unary_union(unions)

hazard_union = chunked_union(hazard_buffers)

# Create the map first
m = folium.Map(location=[sites.geometry.y.mean(), sites.geometry.x.mean()], zoom_start=5)

print("Drawing buffer zone visualization...")
for i, row in hazards_df.iterrows():
    hazard_type = row["Hazards"]
    color_map = {
        "Fire": "orange",
        "Flood": "darkblue",
        "Traffic": "red",
        "PoorRoad": "grey",
        "Poor Road": "grey",
        "Construction": "orange"
    }
    color = next((v for k, v in color_map.items() if k.lower() in hazard_type.lower()), "black")
    
    # Draw large circles for the buffer zones
    radius_m = row['buffer_radius'] * 111_000  # Convert degrees to meters (1 deg ~ 111 km)
    folium.Circle(
        location=[row["Latitude"], row["Longitude"]],
        radius=radius_m,
        color=color,
        weight=2,
        fill=True,
        fill_opacity=0.2,
        popup=f"Buffer zone for {hazard_type} ({radius_m/1000:.1f} km radius)"
    ).add_to(m)

# Inflate length for edges whose midpoint is inside any hazard buffer so
# pathfinding will tend to avoid them.
# Create individual unions for different hazard types
fire_flood_buffers = []
road_condition_buffers = []
other_buffers = []
for i, row in hazards_df.iterrows():
    hazard_type = row["Hazards"]
    if "Fire" in hazard_type or "Flood" in hazard_type:
        fire_flood_buffers.append(hazard_buffers[i])
    elif "Drifting Snow" in hazard_type or "Poor Visibility" in hazard_type:
        road_condition_buffers.append(hazard_buffers[i])
    else:
        other_buffers.append(hazard_buffers[i])

fire_flood_union = unary_union(fire_flood_buffers) if fire_flood_buffers else None
road_condition_union = unary_union(road_condition_buffers) if road_condition_buffers else None
other_hazards_union = unary_union(other_buffers) if other_buffers else None

# Apply different weights based on hazard type
for u, v, key, data in G.edges(keys=True, data=True):
    x = (G.nodes[u]["x"] + G.nodes[v]["x"]) / 2
    y = (G.nodes[u]["y"] + G.nodes[v]["y"]) / 2
    midpoint = Point(x, y)
    
    # Highest weight (25000) for fire and flood hazards
    if fire_flood_union and fire_flood_union.contains(midpoint):
        data["length"] *= 25000
    # Medium weight (15000) for poor visibility and drifting snow
    elif road_condition_union and road_condition_union.contains(midpoint):
        data["length"] *= 15000
    # Regular weight (10000) for other hazards
    elif other_hazards_union and other_hazards_union.contains(midpoint):
        data["length"] *= 10000


# --- Base routes and hazard visualization -------------------------------------------------
# Define hazard styles
hazard_styles = {
    "Fire": {"color": "orange", "icon": "fire"},
    "Flood": {"color": "darkblue", "icon": "water"},
    "Traffic": {"color": "red", "icon": "car"},
    "Construction": {"color": "red", "icon": "wrench"},
    "Drifting Snow": {"color": "lightgray", "icon": "snowflake"},
    "Poor Visibility": {"color": "gray", "icon": "low-vision"},
    "Poor Road": {"color": "red", "icon": "road"}
}

# Add markers for road conditions and construction
for _, row in hazards_df.iterrows():
    lat = row["Latitude"]
    lon = row["Longitude"]
    hazard_type = row["Hazards"]
    
    # Determine style based on hazard type
    style = None
    for k, v in hazard_styles.items():
        if k in hazard_type:
            style = v
            break
    if not style:
        style = {"color": "red", "icon": "exclamation-triangle"}
    
    # Create popup content
    popup_content = hazard_type
    if "Construction" in hazard_type:
        popup_content += "\nThis delay demonstrates the impact of construction on route selection."
    elif "Drifting Snow" in hazard_type:
        popup_content += "\nDrifting snow creates hazardous driving conditions and reduced visibility."
    elif "Poor Visibility" in hazard_type:
        popup_content += "\nPoor visibility conditions significantly affect driving safety."
    
    # Add marker
    folium.Marker(
        location=[lat, lon],
        popup=popup_content,
        icon=folium.Icon(color=style["color"], icon=style["icon"], prefix="fa")
    ).add_to(m)

# Add truck rest area markers only if they're within 30km of any route
try:
    rest_areas = fetch_truck_rest_areas()
    for area in rest_areas:
        point = Point(area["lon"], area["lat"])
        # Check if the rest area is within 30km of any route (0.27 degrees ≈ 30km)
        is_near_route = any(route_line.buffer(0.27).contains(point) for route_line in route_lines.values())
        if is_near_route:
            folium.Marker(
                location=[area["lat"], area["lon"]],
                popup=f"Rest Area: {area['name']}",
                icon=folium.Icon(color="purple", icon="bed", prefix="fa")
            ).add_to(m)
except Exception as e:
    pass

def draw_route_and_get_nodes(G, origin_node, dest_node, color="blue", tooltip=None):
    route = nx.astar_path(G, origin_node, dest_node, heuristic=lambda a, b: haversine(a, b, G), weight="length")
    coords = [(G.nodes[n]['y'], G.nodes[n]['x']) for n in route]
    folium.PolyLine(coords, color=color, weight=5, tooltip=tooltip).add_to(m)
    return route

# Draw all routes and keep route nodes if needed later
route_colors = {"Bruce": "red", "Pickering": "orange", "Darlington": "purple", "Chalk River": "darkgreen"}
routes = {}
for name, origin_node in origins.items():
    tooltip = f"{name} to Ignace"
    color = route_colors.get(name, "blue")
    routes[name] = draw_route_and_get_nodes(G, origin_node, ignace, color=color, tooltip=tooltip)

# Add nuclear site markers with colors matching their routes
site_icon_map = {
    "Bruce Power": dict(color="red", icon="industry", prefix="fa"),  # Matches Bruce route
    "Pickering": dict(color="orange", icon="industry", prefix="fa"),  # Matches Pickering route
    "Darlington": dict(color="purple", icon="industry", prefix="fa"),  # Matches Darlington route
    "Chalk River": dict(color="darkgreen", icon="industry", prefix="fa"),  # Matches Chalk River route
    "CNL Pinawa": dict(color="cadetblue", icon="flask", prefix="fa"),
    "Ignace": dict(color="black", icon="star", prefix="fa"),  # Destination in black to stand out
}
for _, site in sites.iterrows():
    icon_args = site_icon_map.get(site["Name"], dict(color="blue"))
    folium.Marker(
        location=[site.geometry.y, site.geometry.x],
        popup=site["Name"],
        icon=folium.Icon(**icon_args)
    ).add_to(m)


# --- Annotate hazards that affect each route -----------------------------
from collections import defaultdict
route_lines = {}
for name, nodes in routes.items():
    xs = [G.nodes[n]["x"] for n in nodes]
    ys = [G.nodes[n]["y"] for n in nodes]
    # LineString expects (x, y) tuples
    route_lines[name] = LineString(list(zip(xs, ys)))

# Determine which hazards intersect each route and mark them
hazard_affected_by = defaultdict(list)
for i, row in hazards_df.iterrows():
    buf = hazard_buffers[i]
    for origin_name, route_line in route_lines.items():
        if buf.intersects(route_line):
            hazard_affected_by[i].append(origin_name)

for i, row in hazards_df.iterrows():
    affected = hazard_affected_by.get(i, [])
    lat = row["Latitude"]
    lon = row["Longitude"]
    hazard_type = row["Hazards"]
    color_map = {
        "Fire": "orange",
        "Flood": "darkblue",
        "Traffic": "red",
        "PoorRoad": "red",
        "Poor Road": "red",
        "Construction": "red"
    }
    # Define icons for different hazard types
    icon_map = {
        "Fire": "fire",
        "Flood": "water",
        "Traffic": "car",
        "PoorRoad": "road",
        "Poor Road": "road",
        "Construction": "wrench"
    }
    color = None
    icon = None
    for k, v in color_map.items():
        if k.lower() in hazard_type.lower():
            color = v
            icon = icon_map.get(k, "exclamation-triangle")
            break
    if not color:
        color = "black"
        icon = "exclamation-triangle"
    popup = f"{hazard_type} - affects routes: {', '.join(affected)}" if affected else hazard_type
    folium.Marker(
        location=[lat, lon],
        popup=popup,
        icon=folium.Icon(color=color, icon=icon, prefix="fa")
    ).add_to(m)
    
    # Draw buffer zone visualization circle
    radius_m = row['buffer_radius'] * 111_000  # Convert degrees to meters (1 deg ~ 111 km)
    folium.Circle(
        location=[lat, lon],
        radius=radius_m,
        color=color,
        weight=2,
        fill=True,
        fill_opacity=0.2,
        popup=f"Buffer zone for {hazard_type} ({radius_m/1000:.1f} km radius)"
    ).add_to(m)
    # Draw a circle at the centroid of the buffer zone, with correct radius
    buf = hazard_buffers[i]
    if buf.geom_type == "Polygon":
        mid = buf.centroid
        # Calculate radius in meters from buffer area (assuming circular)
        radius_deg = row['buffer_radius']
        radius_m = radius_deg * 111_000  # 1 degree ~ 111 km
        folium.Circle(
            location=[mid.y, mid.x],
            radius=radius_m,
            color=color,
            fill=True,
            fill_opacity=0.15,
            popup=f"Buffer zone for {hazard_type}"
        ).add_to(m)


# Add truck rest area markers only if they're within 30km of any route
try:
    rest_areas = fetch_truck_rest_areas()
    for area in rest_areas:
        point = Point(area["lon"], area["lat"])
        # Check if the rest area is within 30km of any route (0.27 degrees ≈ 30km)
        is_near_route = any(route_line.buffer(0.27).contains(point) for route_line in route_lines.values())
        if is_near_route:
            folium.Marker(
                location=[area["lat"], area["lon"]],
                popup=f"Rest Area: {area['name']}",
                icon=folium.Icon(color="purple", icon="bed", prefix="fa")
            ).add_to(m)
except Exception as e:
    pass

# --- Gas stations (load once) -------------------------------------------
gas_stations_df = pd.read_csv("Refuelling_Truck_Stops.csv")
gas_station_nodes = [
    ox.distance.nearest_nodes(G, row["Longitude"], row["Latitude"])
    for _, row in gas_stations_df.iterrows()
]
gas_stations_df["graph_node"] = gas_station_nodes

max_distance_m = 1_200_000  # 1200 km


def find_refuelling_station(G, origin_node, dest_node, gas_df, max_distance_m):
    """Return (truck_stop_name, graph_node, dist_m) or None.

    Logic: 
    1. Find optimal rest stop near but before 13-hour driving limit (1170 km)
    2. Prefer stops between 11-13 hours for efficiency
    3. Must stop before 13-hour limit for legal compliance
    4. After rest, driver can continue the journey
    """
    try:
        od_dist = nx.shortest_path_length(G, origin_node, dest_node, weight="length")
    except nx.NetworkXNoPath:
        return None

    # Calculate distances for legal driving limits (max 13 hours at 90 km/h)
    avg_speed_kmh = 90
    min_rest_dist = 11 * avg_speed_kmh * 1000  # 990 km in meters
    max_legal_dist = 13 * avg_speed_kmh * 1000  # 1170 km in meters - legal limit
    ideal_rest_dist = 12.5 * avg_speed_kmh * 1000  # 1125 km - optimal rest point
        
    # If total distance is less than minimum rest time, no rest stop needed
    if od_dist < min_rest_dist:
        return None

    reachable = []
    for _, row in gas_df.iterrows():
        station_node = row["graph_node"]
        try:
            d = nx.shortest_path_length(G, origin_node, station_node, weight="length")
            # Calculate driving hours to this station
            hours = (d / 1000) / avg_speed_kmh
            
            # Only consider stops before legal limit
            if d <= max_legal_dist:
                # Score based on how close to ideal rest time (12.5 hours)
                # Lower score is better
                time_score = abs(12.5 - hours)
                
                # Bonus for stops in the sweet spot (11-13 hours)
                if min_rest_dist <= d <= max_legal_dist:
                    time_score -= 1.0
                    
                reachable.append((row["Truck stop"], station_node, d, time_score))
        except nx.NetworkXNoPath:
            continue

    if not reachable:
        # Fall back to original distance-based logic
        reachable = []
        for _, row in gas_df.iterrows():
            station_node = row["graph_node"]
            try:
                d = nx.shortest_path_length(G, origin_node, station_node, weight="length")
                if d <= max_distance_m:
                    reachable.append((row["Truck stop"], station_node, d, float('inf')))
            except nx.NetworkXNoPath:
                continue

    if not reachable:
        return None

    # Choose the station closest to ideal rest time (lowest time_score)
    best_stop = min(reachable, key=lambda x: x[3])
    return best_stop[:3]  # Return only name, node, and distance (strip time_score)


# --- Apply refuelling selection for every origin route ------------------
chosen_stations = {}
colors = {"Bruce": "red", "Pickering": "orange", "Darlington": "purple", "Chalk River": "darkgreen"}
for name, origin_node in origins.items():
    # Only consider gas stations within 30 km of the route
    route_line = route_lines[name]
    # 0.27 degrees is approximately 30km (1 degree ≈ 111km)
    route_buffer = route_line.buffer(0.27)
    filtered_gas_df = gas_stations_df[
        gas_stations_df.apply(lambda row: route_buffer.contains(Point(row["Longitude"], row["Latitude"])), axis=1)
    ]
    station = find_refuelling_station(G, origin_node, ignace, filtered_gas_df, max_distance_m)
    if station:
        stop_name, stop_node, dist_m = station
        chosen_stations[name] = station
        row = filtered_gas_df[filtered_gas_df["graph_node"] == stop_node].iloc[0]
        hours = (dist_m / 1000) / 90
        # Highlight chosen rest stop with a large star marker
        folium.Marker(
            location=[row["Latitude"], row["Longitude"]],
            popup=f"{name} - Rest Stop & Gas Station: {stop_name}\nDistance: {dist_m/1000:.1f} km\nDriving Time: {hours:.1f} hours",
            icon=folium.Icon(color=route_colors.get(name, "red"), icon="star", prefix="fa")
        ).add_to(m)


# Add smaller markers for gas stations within 30km of any route
for _, row in gas_stations_df.iterrows():
    point = Point(row["Longitude"], row["Latitude"])
    # Check if the station is within 30km of any route
    is_near_route = any(route_line.buffer(0.27).contains(point) for route_line in route_lines.values())
    if is_near_route:
        folium.Marker(
            location=[row["Latitude"], row["Longitude"]],
            popup=f"Gas Station: {row['Truck stop']}",
            icon=folium.Icon(color="lightgray", icon="gas-pump", prefix="fa", size=(3, 3))
        ).add_to(m)


# Save map
import time
end_time = time.time()
m.save("Optimized_Nuclear_Route.html")
print(f"Map saved as Optimized_Nuclear_Route.html. Total runtime: {end_time - start_time:.1f} seconds")
